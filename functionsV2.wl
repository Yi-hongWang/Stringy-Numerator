(* ::Package:: *)

(* ::Input:: *)
(*(*Define `CenterDot` as the inner product between vectors and `CircleDot` as the product representing product involving stress tensors.*)*)
(*ClearAll[CenterDot];*)
(*SetAttributes[CenterDot,Orderless]*)
(*x_\[CenterDot]0:=0*)
(*(x_+a_)\[CenterDot]b_:=x\[CenterDot]b+a\[CenterDot]b*)
(*(x_ a_)\[CenterDot]b_:=x (a\[CenterDot]b)/;NumericQ[x]*)
(*ClearAll[CircleDot];*)
(*SetAttributes[CircleDot,Flat]*)
(*x_\[CircleDot]0:=0*)
(*(x_+a_)\[CircleDot]b_:=x\[CircleDot]b+a\[CircleDot]b*)
(*(x_ a_)\[CircleDot]b_:=x (a\[CircleDot]b)/;NumericQ[x];*)
(**)


(* ::Input:: *)
(*(*A tensor term is encoded as a list in the form:{scalar coefficient,tij factors,uncontracted vectors,normal-ordered exponential}.Here,`tij` is represented as a list of indices {i,j} along with its power.Each uncontracted vector is specified by a pair {index,coefficient},and the normal-ordered exponential is labeled by its momentum index.*)*)


(* ::Input:: *)
(*(*`ssope[newVO_List,{coeff_,tij_List,vec_List,klist_List},cvec_List]` This function symbolically computes the result of contracting a new gluon vertex operator with a tensor term over a specified contraction set.The algorithm follows the procedure described in the appendix of the paper.*)ssope[newVO_List,{coeff_,tij_List,vec_List,klist_List},cvec_List]:=Module[{signcvec,ckfs,cefs,newklist,cterms1,cterms2,cterms3,cterms4,ncterm,fterms,terms,rcvec,newtij01,newtij02,newtij1,newcoeff1,maxcvec,cpklist},*)
(*newklist=Append[klist,newVO[[2]]];*)
(*signcvec=((-1)^Length[cvec]);*)
(*maxcvec=If[cvec!={},(SortBy[cvec,Last])[[-1]]];*)
(*rcvec=If[cvec==={},{},Delete[SortBy[cvec,Last],-1]];*)
(*cpklist=Complement[Range[Length[klist]],#[[1]]&/@cvec];*)
(*ckfs=If[rcvec==={},{1},(#/.List-> CircleDot)&/@((Append[#[[2]],newVO[[2]]])&/@rcvec)];*)
(*cefs=(((-1)^(Length[maxcvec[[2]]]-1))((#)/.List-> CircleDot))&/@((#[[2]]~Join~{Symbol[StringReplace[ToString[newVO[[2]]],"k"->"F"]]}~Join~Reverse[maxcvec[[2]]])&/@rcvec);*)
(*newtij01={{#[[1]],Length[klist]+1},-1}&/@cvec;*)
(*newtij02={{#[[1]],Length[klist]+1},-2}&/@cvec;*)
(*newtij1=Table[Table[If[i===j,newtij02[[i]],newtij01[[i]]],{i,1,Length[cvec]}],{j,1,Length[cvec]-1}];*)
(*newcoeff1=Times@@#&/@Table[Table[If[i===j,cefs[[i]],ckfs[[i]]],{i,1,Length[cvec]-1}],{j,1,Length[cvec]-1}];*)
(*cterms1=If[cvec==={},{},If[rcvec==={},{},Table[{signcvec newcoeff1[[i]] coeff,tij~Join~newtij1[[i]],Complement[vec,cvec],newklist},{i,1,Length[cvec]-1}]]];*)
(*cterms2=If[cvec==={},{},Table[{signcvec coeff(If[ckfs==={},1,Times@@ckfs])((maxcvec[[2]]~Join~{Symbol[StringReplace[ToString[newVO[[2]]],"k"->"F"]],klist[[cpklist[[i]]]]})/.List-> CircleDot),(tij~Join~newtij01~Join~{{{cpklist[[i]],Length[klist]+1},-1}})//Sort,Complement[vec,cvec],newklist},{i,1,Length[cpklist]}]];*)
(*cterms3=If[cvec==={},{},{{signcvec coeff(Times@@ckfs),tij~Join~newtij01,Complement[vec,cvec]~Join~{{Length[klist]+1,maxcvec[[2]]~Join~{Symbol[StringReplace[ToString[newVO[[2]]],"k"->"F"]]}}},newklist}}];*)
(*cterms4=Table[{-coeff(CircleDot[newVO[[1]],klist[[i]]]),tij~Join~{{{i,Length[klist]+1},-1}},vec,newklist},{i,1,Length[klist]}];*)
(*ncterm={{coeff,tij,vec~Join~{{Length[klist]+1,{newVO[[1]]}}},newklist}};*)
(*terms=If[cvec==={},cterms4~Join~ncterm,cterms1~Join~cterms2~Join~cterms3];*)
(*Return[terms]]*)


(* ::Input:: *)
(*(*`opef[newVO_List,{coeff_,tij_List,vec_List,klist_List}]` Computes the OPE of a gluon vertex operator `newVO` with a given tensor term {coeff_,tij_List,vec_List,klist_List}.*)*)
(*opef[newVO_List,{coeff_,tij_List,vec_List,klist_List}]:=Join@@(ssope[newVO,{coeff,tij,vec,klist},#]&/@Subsets[vec]);*)


(* ::Input:: *)
(*(*VLOPEF calculates the OPE of a list of gluon vertex operators*)*)
(*ClearAll[Lopef];*)
(*Lopef[newVO_List,termlist_List]:=Join@@(opef[newVO,#]&/@termlist);*)
(*(*`VLOPEF` computes the OPE for a list of gluon vertex operators.*)*)
(*ClearAll[VLOPEF];*)
(*VLOPEF[VOs_List]:=Fold[Lopef[#2,#1]&,opef[VOs[[2]],{1,{},{{1,{VOs[[1,1]]}}},{VOs[[1,2]]}}],Delete[VOs,{{1},{2}}]];*)


(* ::Input:: *)
(*(*`Vopest` calculates the OPE between a tensor term and a scalar vertex operator with momentum `v`.*)*)
(*ClearAll[Vopest];*)
(*Vopest[{coeff_,tij_List,vec_List,klist_List},v_]:=If[vec==={},{coeff,tij,klist~Join~{v}},{Times@@(((#[[2]]~Join~{v})/.List->CircleDot )&/@vec)coeff,tij~Join~({{#[[1]],Length[klist]+1},-1}&/@vec),klist~Join~{v}}];*)


(* ::Input:: *)
(*(*`Integrand[VOs_List,v_]` computes the integrand of the string amplitude for a list of gluons `VOs` and two scalar operators with momenta `v` and `v+k_gluons`.*)*)
(*ClearAll[Integrand];*)
(*Integrand[VOs_List,v_]:=Vopest[#,v]&/@VLOPEF[VOs];*)


(* ::Input:: *)
(*(*`ListtoEdges[tij_List]` converts the `tij` list,which is labeled by endpoints and powers,into a list of edges representing the corresponding graph.*)*)
(*ListtoEdges[tij_List]:=Flatten[Table[#[[1]],{-#[[2]]}]&/@tij,1];*)


(* ::Input:: *)
(*(*`AOQ` verifies whether a graph is a tree rooted at the last vertex with branches in ascending order.*)*)
(*AOQ[l_]:=Module[{vertices,smallerNeighbors,isAcyclic},(*Extract all unique vertices*)vertices=Union[Flatten[l]];*)
(*(*Count neighbors smaller than each vertex*)smallerNeighbors[v_]:=Count[l,{x_,v}/;x<v]+Count[l,{v,x_}/;x<v];*)
(*(*Verify no vertex connects to two or more smaller vertices*)If[Max[smallerNeighbors/@vertices]>=2,Return[False]];*)
(*(*Check if the graph is acyclic (a forest)*)isAcyclic=AcyclicGraphQ[Graph[UndirectedEdge@@@l]];*)
(*(*Return True only if the graph is acyclic*)Return[isAcyclic]];*)


(* ::Input:: *)
(*(*`LOTMS[terms_List,n_Integer]` selects terms that meet the ascending order criteria in an (n+1)-point amplitude.*)*)
(*LOTMS[terms_List,n_Integer]:=Select[terms,AOQ[Select[#[[2]],FreeQ[#,n]&]//ListtoEdges]&];*)


(* ::Input:: *)
(*(*`Branches[tij_List]` analyzes a graph and returns the branches that are connected to the last vertex.*)*)
(*ClearAll[Branches];*)
(*Branches[tij_List]:=Module[{edges,root,neighbors,branches,connectedComponents,odbraches},*)
(*edges=#[[1]]&/@tij;*)
(*root=Max[edges//Flatten];*)
(*(*Find all neighbors of the root vertex*)neighbors=Select[Union[Flatten[edges]],MemberQ[edges,{root,#}]||MemberQ[edges,{#,root}]&];*)
(*(*Remove edges connecting the root to its neighbors to split branches*)branches=Table[(*Find connected components after removing root's edge to the current neighbor*)connectedComponents=ConnectedComponents[Graph[DeleteCases[edges,{root,neighbor}|{neighbor,root}]]];*)
(*(*Extract the component containing the neighbor*)Select[connectedComponents,MemberQ[#,neighbor]&][[1]],{neighbor,neighbors}];*)
(*odbraches=SortBy[branches,First];*)
(*Return[odbraches];];*)


(* ::Input:: *)
(*(*`Intij[tij_]` applies the integration rule (14) from the referenced paper to compute the Park-Taylor factor `tij`.The intermediate functions used within `Intij[tij_]` are:-`\[CapitalTheta][opart_List,i_Integer]`:Generates ordered partitions.-`brchfactor[brch_List,num_Integer]`:Computes the branch factor for a given branch.-`ELVbrch[branches_List]`:Computes the product of branch factors over all branches.*)*)
(*ClearAll[\[CapitalTheta]]*)
(*\[CapitalTheta][opart_List,i_Integer]:=Join@@(Table[Select[opart[[a]],#<opart[[i,1]]&],{a,1,i-1}])//Sort;*)
(*ClearAll[brchfactor]*)
(*brchfactor[brch_List,num_Integer]:=Module[{thlist,ki,Dklist,Dnt,numrt},thlist=Symbol["k"<>ToString[#]]&/@\[CapitalTheta][brch,num];*)
(*ki=Symbol["k"<>ToString[brch[[num,1]]]];*)
(*Dklist=Symbol["k"<>ToString[#]]&/@(Join@@(Table[brch[[i]],{i,1,num-1}]));*)
(*Dnt=(Plus@@Dklist)\[CenterDot]v;*)
(*numrt=(Plus@@thlist)\[CenterDot]ki;*)
(*Return[numrt/Dnt];];*)
(*ClearAll[ELVbrch]*)
(*ELVbrch[branches_List]:=Times@@(Table[brchfactor[branches,i],{i,2,branches//Length}]);*)
(*ClearAll[Intij];*)
(*Intij[tij_]:=Module[{branches,brchorders,sum},branches=SortBy[tij//Branches,First];*)
(*brchorders=Join@@({{branches[[1]]}~Join~#}&/@Permutations[Take[branches,{2,-1}]]);*)
(*sum=Plus@@(ELVbrch[#]&/@brchorders);*)
(*Return[sum];]*)


(* ::Input:: *)
(*(*`termtoil[term_]` converts a contraction factor into a list format that generates ordered partitions.The following intermediate functions are used within `termtoil`:-`Clsfterms[coeff_]`:Classifies terms based on their structure.-`etoindex[sbl_List]`:Converts epsilon symbols to indices.-`Ftoindex[sbl_List]`:Converts F symbols to indices.-`ktoindex[sbl_List]`:Converts k symbols to indices.-`addftbytype[num_,il0_,i_]`:Adds factors by their classified type.-`factortoil[il0_,factor_]`:Constructs the list representation for a given factor.*)*)
(*ClearAll[Clsfterms];*)
(*Clsfterms[coeff_]:=coeff/.Times-> List/.CircleTimes-> List;*)
(*clsfyfactors[flist_]:=If[IntegerQ[flist],1,If[MemberQ[flist,\[Epsilon]1],2,If[Length[flist]>2,3,If[MemberQ[flist,v],4,5]]]];*)
(*ClearAll[etoindex];*)
(*etoindex[sbl_List]:=If[sbl==={},{},ToExpression[StringReplace[ToString[#],"\[Epsilon]"->""]]&/@sbl];*)
(*ClearAll[Ftoindex];*)
(*Ftoindex[sbl_List]:=If[sbl==={},{},ToExpression[StringReplace[ToString[#],"F"->""]]&/@sbl];*)
(*ClearAll[ktoindex];*)
(*ktoindex[sbl_List]:=If[sbl==={},{},ToExpression[StringReplace[ToString[#],"k"->""]]&/@sbl];ClearAll[addftbytype];*)
(*addftbytype[num_,il0_,1]:={num il0[[1]],il0[[2]],il0[[3]],il0[[4]],il0[[5]]};*)
(*addftbytype[flist_,il0_,2]:=Module[{index,il},index=Select[flist//Ftoindex//etoindex,IntegerQ]//Sort;*)
(*il={il0[[1]],il0[[2]]~Join~index,il0[[3]],il0[[4]],il0[[5]]};*)
(*Return[il];]*)
(*addftbytype[flist_,il0_,3]:=Module[{index,il,tau1},index=Select[flist//Ftoindex//etoindex,IntegerQ]//Sort;*)
(*tau1=index[[1]];*)
(*il={il0[[1]],il0[[2]],il0[[3]]~Join~{index},il0[[4]],il0[[5]]};*)
(*Return[il];]*)
(*addftbytype[flist_,il0_,4]:=Module[{index,tau1,il},index=(Select[flist//Ftoindex//etoindex,IntegerQ]);*)
(*tau1=index[[1]];*)
(*il={il0[[1]],il0[[2]],il0[[3]],index~Join~il0[[4]],il0[[5]]};*)
(*Return[il];]*)
(*addftbytype[flist_,il0_,5]:=Module[{index,tau1,il,k},index=(Select[flist//Ftoindex//etoindex,IntegerQ]);*)
(*tau1=index[[1]];*)
(*k=((Complement[flist,index])//ktoindex)[[1]];*)
(*il={il0[[1]],il0[[2]],il0[[3]],il0[[4]],il0[[5]]~Join~{{k,tau1}}};*)
(*Return[il];]*)
(*ClearAll[factortoil];*)
(*factortoil[il0_,factor_]:=Module[{flist,tindex,fclass,il},flist=(factor/.CircleDot-> List);*)
(*fclass=clsfyfactors[flist];*)
(*il=addftbytype[flist,il0,fclass];*)
(*Return[il]];*)
(*ClearAll[termtoil];*)
(*termtoil[term_]:=Fold[factortoil,{1,{},{},{},{}},term/.Times->List/.CircleDot->List];*)


(* ::Input:: *)
(*(*`QMcoeff2[term_]` computes the coefficient of a contraction factor in the Queen Mary result.The following intermediate functions are utilized for this computation:*)*)
(*ClearAll[iltoevekl];*)
(*iltoevekl[{coeff_,tau1_,ltaui_,staui_,ekl_}]:={(#[[1]]&/@ltaui)~Join~staui,ekl};*)
(*ClearAll[ekc1]*)
(*ekc1[listOfLists_List,orderedPair_List]:=Module[{updatedList},(*Check if the first integer of the pair matches the last element of any sublist*)updatedList=If[AnyTrue[listOfLists,MatchQ[#,{___,orderedPair[[1]]}]&],(*If a match is found,append the second integer to the matching sublist*){ReplacePart[listOfLists,FirstPosition[listOfLists,_?(MatchQ[#,{___,orderedPair[[1]]}]&)]->Append[#,orderedPair[[2]]]&@Extract[listOfLists,FirstPosition[listOfLists,_?(MatchQ[#,{___,orderedPair[[1]]}]&)]]],Append[listOfLists,orderedPair]},(*If no match is found,append the ordered pair as a new sublist*){Append[listOfLists,orderedPair]}];*)
(*updatedList];*)
(*ClearAll[ekcl1];*)
(*ekcl1[list_,newek_]:=Join@@(ekc1[#,newek]&/@list);*)
(*ClearAll[ekcall];*)
(*ekcall[useklist_]:=Module[{eklist,cbekl},eklist=SortBy[useklist,Last];*)
(*cbekl=If[eklist==={},{{}},If[Length[eklist]===1,{eklist},Fold[ekcl1,{{eklist[[1]]}},Take[eklist,{2,-1}]]]];*)
(*Return[cbekl];];*)
(*ClearAll[cek1evl];*)
(*cek1evl[newek_,evlist_]:=If[AnyTrue[evlist[[1]],#>newek[[2]]&],(Table[If[evlist[[1,i]]>newek[[2]],{Delete[evlist[[1]],{i}],Append[evlist[[2]],{newek[[1]],newek[[2]],evlist[[1,i]]}]},{}],{i,1,Length[evlist[[1]]]}]),{}];*)
(*ClearAll[pair]*)
(**)
(*(*Main function to generate all valid pairings*)*)
(*pair[lists_List]:=Module[{list1,list2,result={}},(*Extract the two input lists*)list1=lists[[1]];*)
(*list2=lists[[2]];*)
(*(*Helper to generate all pairings*)generatePairs[remainingList1_,remainingList2_,currentPairs_]:=If[remainingList2==={},(*Base case:Store the result when second list is empty*)AppendTo[result,Sort[currentPairs]],(*Sort the current pair list*)(*Iteratively generate pairings*)Do[Do[generatePairs[DeleteCases[remainingList1,a],(*Remove used element from list1*)DeleteCases[remainingList2,b],(*Remove used element from list2*)Append[currentPairs,{a,b}]         (*Add the current pair*)],{b,remainingList2}],{a,remainingList1}]];*)
(*(*Generate the pairings*)generatePairs[list1,list2,{}];*)
(*(*Remove duplicates and return the result*)DeleteDuplicates[result]];*)
(*cekevconfig[evl_List,ekl_List,map_List]:=Module[{sevl,result},sevl=evl//Sort;result=If[And@@Table[evl[[map[[i,1]]]]>ekl[[map[[i,2]],-1]],{i,1,Length[map]}],{{Complement[evl,evl[[#]]&/@(map//Transpose)[[1]]],Table[ekl[[map[[i,2]]]]~Join~{evl[[map[[i,1]]]]},{i,1,Length[map]}]}},{}];*)
(*Return[result];];*)
(*ClearAll[csubekevl];*)
(*csubekevl[evl_List,subekl_List]:=If[subekl==={},{{evl,{}}},Join@@(cekevconfig[evl,subekl,#]&/@(pair[{Range[Length[evl]],Range[Length[subekl]]}]))];*)
(*csubekevlfull[evl_List,ekl_List,subekl_List]:={#,Complement[ekl,subekl]}&/@csubekevl[evl,subekl];*)
(**)
(*ClearAll[cek1evl];*)
(*cek1evl[{evl_List,ekl_List}]:=Join@@((csubekevlfull[evl,ekl,#])&/@Subsets[ekl,Length[evl]]);*)
(*ClearAll[ceklevl];*)
(*ceklevl[{evlist_,eklist_}]:=Module[{cbekl,result},cbekl=ekcall[eklist];result=Join@@Table[(cek1evl[{evlist,cbekl[[i]]}]),{i,1,cbekl//Length}];*)
(*Return[result];];*)
(*ClearAll[cbiltoft];*)
(*cbiltoft[{coeff_,eF1_,eF_List,ev_List,ek_List},{{oevl_,cbekevl_},oekl_}]:=Module[{kvl,kkl,sgn,kkf,kvf},kkl=(Take[#,-2]&/@cbekevl)/. n_Integer:>Symbol["k"<>ToString[n]];*)
(*kkf=Times@@((#[[1]]\[CenterDot]#[[2]])&/@kkl);*)
(*kvl=(#[[-1]]&/@oekl)/. n_Integer:>Symbol["k"<>ToString[n]];*)
(*kvf=Times@@((#\[CenterDot]v)&/@kvl);*)
(*sgn=(-1)^Length[ek];*)
(*Return[sgn kvf kkf coeff];]*)
(*cbiltopt[{coeff_,eF1_,eF_List,ev_List,ek_List},{{oevl_,cbekevl_},oekl_}]:=Module[{tau1,soevl,loevl,scbekevl,lcbekevl1,lcbekevl2,lcbekevl,orders,staui1,staui2,ltaui1,ltaui2,ltaui3},*)
(*soevl=Intersection[ev,oevl];*)
(*loevl=Select[eF,MemberQ[Complement[oevl,soevl],#[[1]]]&];*)
(*scbekevl=Select[cbekevl,MemberQ[ev,#[[-1]]]&];*)
(*lcbekevl1=SortBy[Complement[cbekevl,scbekevl],Last];*)
(*lcbekevl2=SortBy[Complement[eF,loevl],First];*)
(*lcbekevl=Table[Union[lcbekevl1[[i]],lcbekevl2[[i]]],{i,1,lcbekevl1//Length}];*)
(*orders=ek;*)
(*tau1=eF1;*)
(*ltaui1={#,0}&/@loevl;*)
(*ltaui2={Take[#,{2,-1}],#[[1]]}&/@lcbekevl;*)
(*ltaui3={Take[#,{2,-1}],#[[1]]}&/@scbekevl;*)
(*staui1={{#},0}&/@soevl;*)
(*staui2={Take[#,{2,-1}],#[[1]]}&/@oekl;*)
(*Return[{{coeff,tau1,ltaui1~Join~ltaui2~Join~ltaui3~Join~staui1~Join~staui2},orders}];];*)
(*ClearAll[RightOrderQ];*)
(*RightOrderQ[shortList_List,longList_List]:=Module[{positions},(*Find positions of elements of shortList in longList*)positions=Flatten[Position[longList,#]]&/@shortList;*)
(*(*Check if positions are in strictly increasing order*)If[Length[positions]==Length[shortList],OrderedQ[positions],False]];*)
(*NZCoeffQ[{{coeff_,tau1_,taui_},ekorders_}]:=Module[{indexorder,q},indexorder=tau1~Join~(Join@@((taui//Transpose)[[1]]));*)
(*q=And@@(RightOrderQ[#,indexorder]&/@ekorders);*)
(*Return[q];]*)
(*Nzcptorders[{{coeff_,tau1_,taui_},ekorders_}]:=Module[{tiorders,nzlists0,nzlist},tiorders=Permutations[taui];*)
(*nzlists0=Table[If[NZCoeffQ[{{coeff,tau1,tiorders[[i]]},ekorders}],{{coeff,tau1,tiorders[[i]]}},{}],{i,1,tiorders//Length}];*)
(*nzlist=Join@@nzlists0;*)
(*Return[nzlist];]*)
(*ClearAll[Thcoeff];*)
(*Thcoeff[{coeff_,tau1_,taui_}]:=Module[{brch,fl,r,dnt},brch={tau1}~Join~(#[[1]]&/@taui);r=brch//Length;*)
(*fl=Table[If[taui[[i,2]]===0,(Plus@@(\[CapitalTheta][brch,i+1]/. n_Integer:>Symbol["k"<>ToString[n]]))\[CenterDot](Symbol["k"<>ToString[taui[[i,1,1]]]]),1],{i,1,r-1}];*)
(*dnt=Times@@Table[(Plus@@(Symbol["k"<>ToString[#]]&/@(((Take[brch,i])//Flatten)//Sort))\[CenterDot]v),{i,1,r-1}];*)
(*Return[((-1)^r)(Times@@fl)/dnt]]*)
(*EVLT[{coeff_,eF1_,eF_List,ev_List,ek_List},{{oevl_,cbekevl_},oekl_},{coeff_,tau1_,taui_}]:=cbiltoft[{coeff,eF1,eF,ev,ek},{{oevl,cbekevl},oekl}]Thcoeff[{coeff,tau1,taui}];*)
(*ELVP[{coeff_,eF1_,eF_List,ev_List,ek_List},{{oevl_,cbekevl_},oekl_}]:=Module[{ptorders,fl},ptorders=cbiltopt[{coeff,eF1,eF,ev,ek},{{oevl,cbekevl},oekl}]//Nzcptorders;*)
(*fl=EVLT[{coeff,eF1,eF,ev,ek},{{oevl,cbekevl},oekl},#]&/@ptorders;*)
(*Return[Plus@@(fl)]];*)
(*QMcoeff2[term_]:=If[Head[term]===CircleDot||Head[-term]===CircleDot,1,Plus@@(ELVP[(term//termtoil),#]&/@(term//termtoil//iltoevekl//ceklevl))];*)


(* ::Input:: *)
(**)
