(* ::Package:: *)

(* ::Input:: *)
(*(*Define `CenterDot` as the inner product between vectors and `CircleDot` as the product representing product involving stress tensors.*)*)
(*ClearAll[CenterDot];*)
(*SetAttributes[CenterDot,Orderless]*)
(*x_\[CenterDot]0:=0*)
(*(x_+a_)\[CenterDot]b_:=x\[CenterDot]b+a\[CenterDot]b*)
(*(x_ a_)\[CenterDot]b_:=x (a\[CenterDot]b)/;NumericQ[x]*)
(*ClearAll[CircleDot];*)
(*SetAttributes[CircleDot,Flat]*)
(*x_\[CircleDot]0:=0*)
(*0\[CircleDot]x_:=0*)
(*(x_+a_)\[CircleDot]b_:=x\[CircleDot]b+a\[CircleDot]b*)
(*(x_ a_)\[CircleDot]b_:=x (a\[CircleDot]b)/;NumericQ[x];*)
(**)


(* ::Input:: *)
(*(*A tensor term is encoded as a list in the form:{scalar coefficient,tij factors,uncontracted vectors,normal-ordered exponential}.Here,`tij` is represented as a list of indices {i,j} along with its power.Each uncontracted vector is specified by a pair {index,coefficient},and the normal-ordered exponential is labeled by its momentum index.*)*)


(* ::Input:: *)
(*(*`ssope[newVO_List,{coeff_,tij_List,vec_List,klist_List},cvec_List]` This function symbolically computes the result of contracting a new gluon vertex operator with a tensor term over a specified contraction set.The algorithm follows the procedure described in the appendix of the paper.*)ssope[newVO_List,{coeff_,tij_List,vec_List,klist_List},cvec_List]:=Module[{signcvec,ckfs,cefs,newklist,cterms1,cterms2,cterms3,cterms4,ncterm,fterms,terms,rcvec,newtij01,newtij02,newtij1,newcoeff1,maxcvec,cpklist},*)
(*newklist=Append[klist,newVO[[2]]];*)
(*signcvec=((-1)^Length[cvec]);*)
(*maxcvec=If[cvec!={},(SortBy[cvec,Last])[[-1]]];*)
(*rcvec=If[cvec==={},{},Delete[SortBy[cvec,Last],-1]];*)
(*cpklist=Complement[Range[Length[klist]],#[[1]]&/@cvec];*)
(*ckfs=If[rcvec==={},{1},(#/.List-> CircleDot)&/@((Append[#[[2]],newVO[[2]]])&/@rcvec)];*)
(*cefs=(((-1)^(Length[maxcvec[[2]]]-1))((#)/.List-> CircleDot))&/@((#[[2]]~Join~{Symbol[StringReplace[ToString[newVO[[2]]],"k"->"F"]]}~Join~Reverse[maxcvec[[2]]])&/@rcvec);*)
(*newtij01={{#[[1]],Length[klist]+1},-1}&/@cvec;*)
(*newtij02={{#[[1]],Length[klist]+1},-2}&/@cvec;*)
(*newtij1=Table[Table[If[i===j,newtij02[[i]],newtij01[[i]]],{i,1,Length[cvec]}],{j,1,Length[cvec]-1}];*)
(*newcoeff1=Times@@#&/@Table[Table[If[i===j,cefs[[i]],ckfs[[i]]],{i,1,Length[cvec]-1}],{j,1,Length[cvec]-1}];*)
(*cterms1=If[cvec==={},{},If[rcvec==={},{},Table[{signcvec newcoeff1[[i]] coeff,tij~Join~newtij1[[i]],Complement[vec,cvec],newklist},{i,1,Length[cvec]-1}]]];*)
(*cterms2=If[cvec==={},{},Table[{signcvec coeff(If[ckfs==={},1,Times@@ckfs])((maxcvec[[2]]~Join~{Symbol[StringReplace[ToString[newVO[[2]]],"k"->"F"]],klist[[cpklist[[i]]]]})/.List-> CircleDot),(tij~Join~newtij01~Join~{{{cpklist[[i]],Length[klist]+1},-1}})//Sort,Complement[vec,cvec],newklist},{i,1,Length[cpklist]}]];*)
(*cterms3=If[cvec==={},{},{{signcvec coeff(Times@@ckfs),tij~Join~newtij01,Complement[vec,cvec]~Join~{{Length[klist]+1,maxcvec[[2]]~Join~{Symbol[StringReplace[ToString[newVO[[2]]],"k"->"F"]]}}},newklist}}];*)
(*cterms4=Table[{coeff(CircleDot[newVO[[1]],klist[[i]]]),tij~Join~{{{i,Length[klist]+1},-1}},vec,newklist},{i,1,Length[klist]}];*)
(*ncterm={{coeff,tij,vec~Join~{{Length[klist]+1,{newVO[[1]]}}},newklist}};*)
(*terms=If[cvec==={},cterms4~Join~ncterm,cterms1~Join~cterms2~Join~cterms3];*)
(*Return[terms]]*)


(* ::Input:: *)
(*(*`opef[newVO_List,{coeff_,tij_List,vec_List,klist_List}]` Computes the OPE of a gluon vertex operator `newVO` with a given tensor term {coeff_,tij_List,vec_List,klist_List}.*)*)
(*opef[newVO_List,{coeff_,tij_List,vec_List,klist_List}]:=Join@@(ssope[newVO,{coeff,tij,vec,klist},#]&/@Subsets[vec]);*)


(* ::Input:: *)
(*(*VLOPEF calculates the OPE of a list of gluon vertex operators*)*)
(*ClearAll[Lopef];*)
(*Lopef[newVO_List,termlist_List]:=Join@@(opef[newVO,#]&/@termlist);*)
(*(*`VLOPEF` computes the OPE for a list of gluon vertex operators.*)*)
(*ClearAll[VLOPEF];*)
(*VLOPEF[VOs_List]:=Fold[Lopef[#2,#1]&,opef[VOs[[2]],{1,{},{{1,{VOs[[1,1]]}}},{VOs[[1,2]]}}],Delete[VOs,{{1},{2}}]];*)


(* ::Input:: *)
(*(*`Vopest` calculates the OPE between a tensor term and a scalar vertex operator with momentum `p`.*)*)
(*ClearAll[Vopest];*)
(*Vopest[{coeff_,tij_List,vec_List,klist_List},p_]:=If[vec==={},{coeff,tij,klist~Join~{p}},{Times@@(((#[[2]]~Join~{p})/.List->CircleDot )&/@vec)coeff (-1)^Length[vec],tij~Join~({{#[[1]],Length[klist]+1},-1}&/@vec),klist~Join~{p}}];*)


(* ::Input:: *)
(*(*`Integrand[VOs_List,v_]` computes the integrand of the string amplitude for a list of gluons `VOs` and two scalar operators with momenta `v` and `v+k_gluons`.*)*)
(*ClearAll[Integrand];*)
(*Integrand[VOs_List,p_]:=Vopest[#,p]&/@VLOPEF[VOs];*)


(* ::Input:: *)
(*(*`ListtoEdges[tij_List]` converts the `tij` list,which is labeled by endpoints and powers,into a list of edges representing the corresponding graph.*)*)
(*ListtoEdges[tij_List]:=Flatten[Table[#[[1]],{-#[[2]]}]&/@tij,1];*)


(* ::Input:: *)
(*(*`AOQ` verifies whether a graph is a tree rooted at the last vertex with branches in ascending order.*)*)
(*AOQ[l_]:=Module[{vertices,smallerNeighbors,isAcyclic},(*Extract all unique vertices*)vertices=Union[Flatten[l]];*)
(*(*Count neighbors smaller than each vertex*)smallerNeighbors[p_]:=Count[l,{x_,p}/;x<p]+Count[l,{p,x_}/;x<p];*)
(*(*Verify no vertex connects to two or more smaller vertices*)If[Max[smallerNeighbors/@vertices]>=2,Return[False]];*)
(*(*Check if the graph is acyclic (a forest)*)isAcyclic=AcyclicGraphQ[Graph[UndirectedEdge@@@l]];*)
(*(*Return True only if the graph is acyclic*)Return[isAcyclic]];*)


(* ::Input:: *)
(*(*`LOTMS[terms_List,n_Integer]` selects terms that meet the ascending order criteria in an (n+1)-point amplitude.*)*)
(*LOTMS[terms_List,n_Integer]:=Select[terms,AOQ[Select[#[[2]],FreeQ[#,n]&]//ListtoEdges]&];*)


(* ::Input:: *)
(*(*`Branches[tij_List]` analyzes a graph and returns the branches that are connected to the last vertex.*)*)
(*ClearAll[Branches];*)
(*Branches[tij_List]:=Module[{edges,root,neighbors,branches,connectedComponents,odbraches},*)
(*edges=#[[1]]&/@tij;*)
(*root=Max[edges//Flatten];*)
(*(*Find all neighbors of the root vertex*)neighbors=Select[Union[Flatten[edges]],MemberQ[edges,{root,#}]||MemberQ[edges,{#,root}]&];*)
(*(*Remove edges connecting the root to its neighbors to split branches*)branches=Table[(*Find connected components after removing root's edge to the current neighbor*)connectedComponents=ConnectedComponents[Graph[DeleteCases[edges,{root,neighbor}|{neighbor,root}]]];*)
(*(*Extract the component containing the neighbor*)Select[connectedComponents,MemberQ[#,neighbor]&][[1]],{neighbor,neighbors}];*)
(*odbraches=SortBy[branches,First];*)
(*Return[odbraches];];*)


(* ::Input:: *)
(*(*`Intij[tij_]` applies the integration rule (14) from the referenced paper to compute the Park-Taylor factor `tij`.The intermediate functions used within `Intij[tij_]` are:-`\[CapitalTheta][opart_List,i_Integer]`:Generates ordered partitions.-`brchfactor[brch_List,num_Integer]`:Computes the branch factor for a given branch.-`ELVbrch[branches_List]`:Computes the product of branch factors over all branches.*)*)
(*ClearAll[\[CapitalTheta]]*)
(*\[CapitalTheta][opart_List,i_Integer]:=Join@@(Table[Select[opart[[a]],#<opart[[i,1]]&],{a,1,i-1}])//Sort;*)
(*ClearAll[brchfactor]*)
(*brchfactor[brch_List,num_Integer]:=Module[{thlist,ki,Dklist,Dnt,numrt},thlist=Symbol["k"<>ToString[#]]&/@\[CapitalTheta][brch,num];*)
(*ki=Symbol["k"<>ToString[brch[[num,1]]]];*)
(*Dklist=Symbol["k"<>ToString[#]]&/@(Join@@(Table[brch[[i]],{i,1,num-1}]));*)
(*Dnt=(Plus@@Dklist)\[CenterDot]p;*)
(*numrt=(Plus@@thlist)\[CenterDot]ki;*)
(*Return[-numrt/Dnt];];*)
(*ClearAll[ELVbrch]*)
(*ELVbrch[branches_List]:=Times@@(Table[brchfactor[branches,i],{i,2,branches//Length}]);*)
(*ClearAll[Intij];*)
(*Intij[tij_]:=Module[{branches,brchorders,sum},branches=SortBy[tij//Branches,First];*)
(*brchorders=Join@@({{branches[[1]]}~Join~#}&/@Permutations[Take[branches,{2,-1}]]);*)
(*sum=Plus@@(ELVbrch[#]&/@brchorders);*)
(*Return[sum];]*)


(* ::Input:: *)
(*(*GVL[n_Integer] generates the list of {\[Epsilon]i,ki} up to {\[Epsilon]n,kn}*)*)
(*GVL[n_Integer]:={ToExpression["\[Epsilon]"<>ToString[#]],ToExpression["k"<>ToString[#]]}&/@Range[n];*)


(* ::Input:: *)
(*(*AOTree[n_Integer,p_] generates terms in the n-gluon integrand*)*)
(*AOTree[n_Integer,p_]:=LOTMS[DeleteCases[Integrand[GVL[n],p]/.\[Epsilon]1\[CircleDot]p-> 0,{0,_,_}],n+1];*)


(* ::Input:: *)
(*(*NumFTL[n_Integer,p_] generates the field theory limit of the numerator*)*)
(*NumFTL[n_Integer,p_]:=Plus@@((#[[1]] (#[[2]]//Intij))&/@AOTree[n,p]);*)


(* ::Input:: *)
(*(*gsrule1[n_Integer,p_] and gsrule2[n_Integer,p_]generates rules for the gauge shift*)*)
(*ClearAll[gsrule1];*)
(*gsrule1[n_Integer,p_]:=Table[ToExpression["\[Epsilon]"<>ToString[i]]\[CircleDot]p->0,{i,1,n}];ClearAll[gsrule2];*)
(*gsrule2[n_Integer,p_]:=Table[With[{eps=ToExpression["\[Epsilon]"<>ToString[i]],F=ToExpression["F"<>ToString[i]],k=ToExpression["k"<>ToString[i]]},eps\[CircleDot]x_:>(p\[CircleDot]F\[CircleDot]x)/(k\[CenterDot]p)],{i,1,n}];*)


(* ::Input:: *)
(*(*GIAOTree[n_Integer,p_] generates terms in the gauge invariant n-gluon integrand*)*)
(*GIAOTree[n_Integer,p_]:=DeleteCases[AOTree[n,p]/.gsrule1[n,p],{0,_,_}]/.gsrule2[n,p]*)


(* ::Input:: *)
(*(*GINum[n_Integer,p_] generates the gauge invariant  numerator*)*)
(*ClearAll[SwappFk]*)
(*SwappFk[expr_]:=expr/. p\[CircleDot]F_Symbol\[CircleDot]k_Symbol/;(StringMatchQ[SymbolName[F],"F"~~DigitCharacter..]&&StringMatchQ[SymbolName[k],"k"~~DigitCharacter..]):>-k\[CircleDot]F\[CircleDot]p*)
(*GINum[n_Integer,p_]:=Plus@@((#[[1]] (#[[2]]//Intij))&/@GIAOTree[n,p])//SwappFk;*)


(* ::Input:: *)
(*(*QMNum[n_Integer,p_] computes the Queen Mary (QM) result for the numerator in the Heavy Effective Field Theory (HEFT) approach.The function generates all partitions of a given set,converts them into tau representations,and evaluates the corresponding expressions using symbolic operations.Key components:-`taufactor`:Computes individual tau factors for each branch.-`ELVtau`:Evaluates the product of tau factors over all branches.-`lpt` and `lpts`:Generate all possible partitions of a list.-`parttotau`:Converts partitions into tau forms.-`tautoT`:Transforms tau representations into the final symbolic product form using CircleDot and symbolic kinematics.-`QMNum`:The main function,which applies alternating signs and sums over all possible tau representations to produce the final HEFT numerator result.*)*)
(*ClearAll[taufactor];*)
(*taufactor[brch_List,num_Integer]:=Module[{thlist,Flist,Dklist,Dnt,numrt},thlist=If[num===1,{v},Symbol["k"<>ToString[#]]&/@\[CapitalTheta][brch,num]];*)
(*Flist=Symbol["F"<>ToString[#]]&/@brch[[num]];*)
(*Dklist=If[num===1,{1/v},Symbol["k"<>ToString[#]]&/@(Join@@(Table[brch[[i]],{i,1,num-1}]))];*)
(*Dnt=If[num===1,1,(Plus@@Dklist)\[CenterDot]v];*)
(*numrt=(Plus@@thlist)\[CircleDot](CircleDot@@Flist)\[CircleDot]v;*)
(*Return[numrt/Dnt];];*)
(*ClearAll[ELVtau];*)
(*ELVtau[branches_List]:=Times@@(Table[taufactor[branches,i],{i,1,branches//Length}]);ClearAll[lpt];*)
(*ClearAll[lpts];*)
(*lpt[{}]={{}};*)
(*lpt[s_List]:=Module[{x,rest,partitions},x=First[s];*)
(*rest=Rest[s];*)
(*partitions=lpt[rest];*)
(*Flatten[Join[Table[ReplacePart[p,i->Append[p[[i]],x]],{p,partitions},{i,Length[p]}],{Append[#,{x}]&/@partitions}],1]];*)
(*lpts[s_List]:=Table[Sort[#]&/@((lpt[s])[[a]]),{a,1,Length[lpt[s]]}];*)
(*ClearAll[parttotau];*)
(*parttotau[part_List]:=If[Length[part]===1,{{{1}~Join~part[[1]]}},Join@@Table[({{1}~Join~part[[l]]}~Join~#)&/@Permutations[Delete[part,{l}]],{l,1,Length[part]}]];*)
(*ClearAll[tautoT];*)
(*tautoT[tau_List,p_]:=(1/(k1\[CenterDot]p)) CircleDot@@({p}~Join~(ToExpression["F"<>ToString[#]]&/@tau[[1]])~Join~{p})(Product[(CircleDot@@({Plus@@(ToExpression["k"<>ToString[#]]&/@\[CapitalTheta][tau,l])}~Join~(ToExpression["F"<>ToString[#]]&/@tau[[l]])~Join~{p})),{l,2,Length[tau]}])/(Product[(Plus@@(ToExpression["k"<>ToString[#]]&/@(Take[tau,l]//Flatten)))\[CenterDot]p,{l,1,Length[tau]-1}])*)
(*ClearAll[QMNum];*)
(*QMNum[n_Integer,p_]:=((-1)^n)(Plus@@((((-1)^(Length[#]-1))tautoT[#,p])&/@(Join@@(parttotau/@(Range[2,n]//lpts)))));*)
(**)


(* ::Input:: *)
(*(*`termtoil[term_]` converts a contraction factor into a list format that generates ordered partitions.The following intermediate functions are used within `termtoil`:-`Clsfterms[coeff_]`:Classifies terms based on their structure.-`etoindex[sbl_List]`:Converts epsilon symbols to indices.-`Ftoindex[sbl_List]`:Converts F symbols to indices.-`ktoindex[sbl_List]`:Converts k symbols to indices.-`addftbytype[num_,il0_,i_]`:Adds factors by their classified type.-`factortoil[il0_,factor_]`:Constructs the list representation for a given factor.*)*)
(*ClearAll[Clsfterms];*)
(*Clsfterms[coeff_]:=coeff/.Times-> List/.CircleTimes-> List;*)
(*clsfyfactors[flist_]:=If[IntegerQ[flist],1,If[MemberQ[flist,\[Epsilon]1],2,If[Length[flist]>2,3,If[MemberQ[flist,p],4,5]]]];*)
(*ClearAll[etoindex];*)
(*etoindex[sbl_List]:=If[sbl==={},{},ToExpression[StringReplace[ToString[#],"\[Epsilon]"->""]]&/@sbl];*)
(*ClearAll[Ftoindex];*)
(*Ftoindex[sbl_List]:=If[sbl==={},{},ToExpression[StringReplace[ToString[#],"F"->""]]&/@sbl];*)
(*ClearAll[ktoindex];*)
(*ktoindex[sbl_List]:=If[sbl==={},{},ToExpression[StringReplace[ToString[#],"k"->""]]&/@sbl];ClearAll[addftbytype];*)
(*addftbytype[num_,il0_,1]:={num il0[[1]],il0[[2]],il0[[3]],il0[[4]],il0[[5]]};*)
(*addftbytype[flist_,il0_,2]:=Module[{index,il},index=Select[flist//Ftoindex//etoindex,IntegerQ]//Sort;*)
(*il={il0[[1]],il0[[2]]~Join~index,il0[[3]],il0[[4]],il0[[5]]};*)
(*Return[il];]*)
(*addftbytype[flist_,il0_,3]:=Module[{index,il,tau1},index=Select[flist//Ftoindex//etoindex,IntegerQ]//Sort;*)
(*tau1=index[[1]];*)
(*il={il0[[1]],il0[[2]],il0[[3]]~Join~{index},il0[[4]],il0[[5]]};*)
(*Return[il];]*)
(*addftbytype[flist_,il0_,4]:=Module[{index,tau1,il},index=(Select[flist//Ftoindex//etoindex,IntegerQ]);*)
(*tau1=index[[1]];*)
(*il={il0[[1]],il0[[2]],il0[[3]],index~Join~il0[[4]],il0[[5]]};*)
(*Return[il];]*)
(*addftbytype[flist_,il0_,5]:=Module[{index,tau1,il,k},index=(Select[flist//Ftoindex//etoindex,IntegerQ]);*)
(*tau1=index[[1]];*)
(*k=((Complement[flist,index])//ktoindex)[[1]];*)
(*il={il0[[1]],il0[[2]],il0[[3]],il0[[4]],il0[[5]]~Join~{{k,tau1}}};*)
(*Return[il];]*)
(*ClearAll[factortoil];*)
(*factortoil[il0_,factor_]:=Module[{flist,tindex,fclass,il},flist=(factor/.CircleDot-> List);*)
(*fclass=clsfyfactors[flist];*)
(*il=addftbytype[flist,il0,fclass];*)
(*Return[il]];*)
(*ClearAll[termtoil];*)
(*termtoil[term_]:=Fold[factortoil,{1,{},{},{},{}},term/.Times->List/.CircleDot->List];*)


(* ::Input:: *)
(*(*`QMcoeff[term_]` computes the coefficient of a contraction factor in the Queen Mary result.The following intermediate functions are utilized for this computation:*)*)
(*ClearAll[iltoevekl];*)
(*iltoevekl[{coeff_,tau1_,ltaui_,staui_,ekl_}]:={(#[[1]]&/@ltaui)~Join~staui,ekl};*)
(*ClearAll[ekc1]*)
(*ekc1[listOfLists_List,orderedPair_List]:=Module[{updatedList},(*Check if the first integer of the pair matches the last element of any sublist*)updatedList=If[AnyTrue[listOfLists,MatchQ[#,{___,orderedPair[[1]]}]&],(*If a match is found,append the second integer to the matching sublist*){ReplacePart[listOfLists,FirstPosition[listOfLists,_?(MatchQ[#,{___,orderedPair[[1]]}]&)]->Append[#,orderedPair[[2]]]&@Extract[listOfLists,FirstPosition[listOfLists,_?(MatchQ[#,{___,orderedPair[[1]]}]&)]]],Append[listOfLists,orderedPair]},(*If no match is found,append the ordered pair as a new sublist*){Append[listOfLists,orderedPair]}];*)
(*updatedList];*)
(*ClearAll[ekcl1];*)
(*ekcl1[list_,newek_]:=Join@@(ekc1[#,newek]&/@list);*)
(*ClearAll[ekcall];*)
(*ekcall[useklist_]:=Module[{eklist,cbekl},eklist=SortBy[useklist,Last];*)
(*cbekl=If[eklist==={},{{}},If[Length[eklist]===1,{eklist},Fold[ekcl1,{{eklist[[1]]}},Take[eklist,{2,-1}]]]];*)
(*Return[cbekl];];*)
(*ClearAll[cek1evl];*)
(*cek1evl[newek_,evlist_]:=If[AnyTrue[evlist[[1]],#>newek[[2]]&],(Table[If[evlist[[1,i]]>newek[[2]],{Delete[evlist[[1]],{i}],Append[evlist[[2]],{newek[[1]],newek[[2]],evlist[[1,i]]}]},{}],{i,1,Length[evlist[[1]]]}]),{}];*)
(*ClearAll[pair]*)
(**)
(*(*Main function to generate all valid pairings*)*)
(*pair[lists_List]:=Module[{list1,list2,result={}},(*Extract the two input lists*)list1=lists[[1]];*)
(*list2=lists[[2]];*)
(*(*Helper to generate all pairings*)generatePairs[remainingList1_,remainingList2_,currentPairs_]:=If[remainingList2==={},(*Base case:Store the result when second list is empty*)AppendTo[result,Sort[currentPairs]],(*Sort the current pair list*)(*Iteratively generate pairings*)Do[Do[generatePairs[DeleteCases[remainingList1,a],(*Remove used element from list1*)DeleteCases[remainingList2,b],(*Remove used element from list2*)Append[currentPairs,{a,b}]         (*Add the current pair*)],{b,remainingList2}],{a,remainingList1}]];*)
(*(*Generate the pairings*)generatePairs[list1,list2,{}];*)
(*(*Remove duplicates and return the result*)DeleteDuplicates[result]];*)
(*cekevconfig[evl_List,ekl_List,map_List]:=Module[{sevl,result},sevl=evl//Sort;result=If[And@@Table[evl[[map[[i,1]]]]>ekl[[map[[i,2]],-1]],{i,1,Length[map]}],{{Complement[evl,evl[[#]]&/@(map//Transpose)[[1]]],Table[ekl[[map[[i,2]]]]~Join~{evl[[map[[i,1]]]]},{i,1,Length[map]}]}},{}];*)
(*Return[result];];*)
(*ClearAll[csubekevl];*)
(*csubekevl[evl_List,subekl_List]:=If[subekl==={},{{evl,{}}},Join@@(cekevconfig[evl,subekl,#]&/@(pair[{Range[Length[evl]],Range[Length[subekl]]}]))];*)
(*csubekevlfull[evl_List,ekl_List,subekl_List]:={#,Complement[ekl,subekl]}&/@csubekevl[evl,subekl];*)
(**)
(*ClearAll[cek1evl];*)
(*cek1evl[{evl_List,ekl_List}]:=Join@@((csubekevlfull[evl,ekl,#])&/@Subsets[ekl,Length[evl]]);*)
(*ClearAll[ceklevl];*)
(*ceklevl[{evlist_,eklist_}]:=Module[{cbekl,result},cbekl=ekcall[eklist];result=Join@@Table[(cek1evl[{evlist,cbekl[[i]]}]),{i,1,cbekl//Length}];*)
(*Return[result];];*)
(*ClearAll[cbiltoft];*)
(*cbiltoft[{coeff_,eF1_,eF_List,ev_List,ek_List},{{oevl_,cbekevl_},oekl_}]:=Module[{kvl,kkl,sgn,kkf,kvf},kkl=(Take[#,-2]&/@cbekevl)/. n_Integer:>Symbol["k"<>ToString[n]];*)
(*kkf=Times@@((#[[1]]\[CenterDot]#[[2]])&/@kkl);*)
(*kvl=(#[[-1]]&/@oekl)/. n_Integer:>Symbol["k"<>ToString[n]];*)
(*kvf=Times@@((#\[CenterDot]p)&/@kvl);*)
(*sgn=(-1)^Length[ek];*)
(*Return[sgn kvf kkf coeff];]*)
(*cbiltopt[{coeff_,eF1_,eF_List,ev_List,ek_List},{{oevl_,cbekevl_},oekl_}]:=Module[{tau1,soevl,loevl,scbekevl,lcbekevl1,lcbekevl2,lcbekevl,orders,staui1,staui2,ltaui1,ltaui2,ltaui3},*)
(*soevl=Intersection[ev,oevl];*)
(*loevl=Select[eF,MemberQ[Complement[oevl,soevl],#[[1]]]&];*)
(*scbekevl=Select[cbekevl,MemberQ[ev,#[[-1]]]&];*)
(*lcbekevl1=SortBy[Complement[cbekevl,scbekevl],Last];*)
(*lcbekevl2=SortBy[Complement[eF,loevl],First];*)
(*lcbekevl=Table[Union[lcbekevl1[[i]],lcbekevl2[[i]]],{i,1,lcbekevl1//Length}];*)
(*orders=ek;*)
(*tau1=eF1;*)
(*ltaui1={#,0}&/@loevl;*)
(*ltaui2={Take[#,{2,-1}],#[[1]]}&/@lcbekevl;*)
(*ltaui3={Take[#,{2,-1}],#[[1]]}&/@scbekevl;*)
(*staui1={{#},0}&/@soevl;*)
(*staui2={Take[#,{2,-1}],#[[1]]}&/@oekl;*)
(*Return[{{coeff,tau1,ltaui1~Join~ltaui2~Join~ltaui3~Join~staui1~Join~staui2},orders}];];*)
(*ClearAll[RightOrderQ];*)
(*RightOrderQ[shortList_List,longList_List]:=Module[{positions},(*Find positions of elements of shortList in longList*)positions=Flatten[Position[longList,#]]&/@shortList;*)
(*(*Check if positions are in strictly increasing order*)If[Length[positions]==Length[shortList],OrderedQ[positions],False]];*)
(*NZCoeffQ[{{coeff_,tau1_,taui_},ekorders_}]:=Module[{indexorder,q},indexorder=tau1~Join~(Join@@((taui//Transpose)[[1]]));*)
(*q=And@@(RightOrderQ[#,indexorder]&/@ekorders);*)
(*Return[q];]*)
(*Nzcptorders[{{coeff_,tau1_,taui_},ekorders_}]:=Module[{tiorders,nzlists0,nzlist},tiorders=Permutations[taui];*)
(*nzlists0=Table[If[NZCoeffQ[{{coeff,tau1,tiorders[[i]]},ekorders}],{{coeff,tau1,tiorders[[i]]}},{}],{i,1,tiorders//Length}];*)
(*nzlist=Join@@nzlists0;*)
(*Return[nzlist];]*)
(*ClearAll[Thcoeff];*)
(*Thcoeff[{coeff_,tau1_,taui_}]:=Module[{brch,fl,r,dnt},brch={tau1}~Join~(#[[1]]&/@taui);r=brch//Length;*)
(*fl=Table[If[taui[[i,2]]===0,(Plus@@(\[CapitalTheta][brch,i+1]/. n_Integer:>Symbol["k"<>ToString[n]]))\[CenterDot](Symbol["k"<>ToString[taui[[i,1,1]]]]),1],{i,1,r-1}];*)
(*dnt=Times@@Table[(Plus@@(Symbol["k"<>ToString[#]]&/@(((Take[brch,i])//Flatten)//Sort))\[CenterDot]p),{i,1,r-1}];*)
(*Return[((-1)^r)(Times@@fl)/dnt]]*)
(*EVLT[{coeff_,eF1_,eF_List,ev_List,ek_List},{{oevl_,cbekevl_},oekl_},{coeff_,tau1_,taui_}]:=cbiltoft[{coeff,eF1,eF,ev,ek},{{oevl,cbekevl},oekl}]Thcoeff[{coeff,tau1,taui}];*)
(*ELVP[{coeff_,eF1_,eF_List,ev_List,ek_List},{{oevl_,cbekevl_},oekl_}]:=Module[{ptorders,fl},ptorders=cbiltopt[{coeff,eF1,eF,ev,ek},{{oevl,cbekevl},oekl}]//Nzcptorders;*)
(*fl=EVLT[{coeff,eF1,eF,ev,ek},{{oevl,cbekevl},oekl},#]&/@ptorders;*)
(*Return[Plus@@(fl)]];*)
(*ClearAll[nf];*)
(*nf[term_]:=If[Head[term]===CircleDot||Head[-term]===CircleDot,1,(term/.Times->List)//Length];*)
(*ClearAll[QMcoeff];*)
(*QMcoeff[term_]:= If[Head[term]===CircleDot,1,If[Head[-term]===CircleDot,-1,-(Plus@@(ELVP[(term//termtoil),#]&/@(term//termtoil//iltoevekl//ceklevl)))]];*)
(**)


(* ::Input:: *)
(*(*oscdt[n_Integer,p_] generates the npt on shell condition rule*)*)
(*ClearAll[oscdt];*)
(*oscdt[n_Integer,p_]:=ToExpression["k"<>ToString[n]]\[CenterDot]p->-Total[Table[ToExpression["k"<>ToString[i]]\[CenterDot]p,{i,1,n-1}]];*)
(**)


(* ::Input:: *)
(*(*termmatch[term_List,n_Integer] computes the difference beteewn the coefficients of each contraction factor in our result and the QMUL result*)*)
(*ClearAll[termmatch];*)
(*termmatch[term_List,n_Integer]:=(term[[2]]//Intij)-((-1)^n)(term[[1]]//QMcoeff);*)


(* ::Input:: *)
(*(*ELVcdsum[sum_] evaluates expressions involving CircleDot (\[CircleDot]) products and Fi symbols,converting them into inner products (CenterDot) of momenta ki and polarization vectors \[CurlyEpsilon]i.*)
(*Key components:-`stfactor`:Returns {ki,\[CurlyEpsilon]i} or {\[CurlyEpsilon]i,ki} based on the given index and sign (1 or-1).-`stterm`:Constructs a term using a list of indices,head,end,and sign list,combining inner products accordingly.-`ELVCcdot`:Evaluates a CircleDot product by generating all sign combinations,applying `stterm`,and summing the results.-`ELVcdprd`:Applies `ELVCcdot` to each factor in a product.-`ELVcdsum`:Recursively applies `ELVcdprd` to each term in a sum and sums the results.*)*)
(*ClearAll[stfactor];*)
(*stfactor[index_Integer,tsign:(1|-1)]:=If[tsign===1,{ToExpression["k"<>ToString[index]],ToExpression["\[Epsilon]"<>ToString[index]]},{ToExpression["\[Epsilon]"<>ToString[index]],ToExpression["k"<>ToString[index]]}];*)
(*ClearAll[stterm];*)
(*stterm[indices_List,head_,end_,signlist_List]:=Module[{stfl,term,maxl},stfl=Table[stfactor[indices[[l]],signlist[[l]]],{l,1,Length[indices]}]//Flatten;*)
(*maxl=(Length[stfl]-2)/2;*)
(*term=(Times@@signlist)(head\[CenterDot]stfl[[1]]) (Product[stfl[[2l]]\[CenterDot]stfl[[2l+1]],{l,1,maxl}]) (stfl[[-1]]\[CenterDot]end);*)
(*Return[term];*)
(*];*)
(*ClearAll[EVCcdot];*)
(*EVCcdot[factor_]:=If[(!(Head[factor]===CircleDot)),factor,If[(Length[factor]===2),factor/.CircleDot->CenterDot,Module[{fl0,hd,end,fl,signlist,terms,sum},fl0=factor/.CircleDot->List;*)
(*hd=fl0[[1]];*)
(*end=fl0[[-1]];*)
(*fl=(Take[fl0,{2,-2}])//Ftoindex;*)
(*signlist=Tuples[{1,-1},Length[fl]];*)
(*terms=stterm[fl,hd,end,#]&/@signlist;*)
(*sum=Plus@@terms;*)
(*Return[sum];]]];*)
(*ClearAll[EVterm];*)
(*EVterm[term_]:=term/. x_CircleDot:>EVCcdot[x]/;Head[x]===CircleDot;*)


(* ::Input:: *)
(*tijplot[n_Integer,tij_List]:=Graph[Range[n+1],(tij//ListtoEdges),VertexLabels->"Name",ImageSize->80,GraphLayout->{"LayeredDigraphEmbedding","RootVertex"->(n+1),"Orientation"->Right},ImagePadding->10];*)


(* ::Input:: *)
(*ClearAll[DrawRootedTree]*)
(*DrawRootedTree[edges_List]:=Module[{n,g,coords,maxX,midY},(*Find the maximum vertex number as n*)n=Max[Flatten[edges]];*)
(*(*Create initial graph using LayeredDigraphEmbedding*)g=Graph[Range[n],edges,VertexLabels->"Name",GraphLayout->{"LayeredDigraphEmbedding","RootVertex"->n,"Orientation"->Left}];*)
(*(*Get initial coordinates from the embedding*)coords=GraphEmbedding[g];*)
(*(*Determine the maximum x coordinate and midpoint of y coordinates*)maxX=Max[coords[[All,1]]];*)
(*midY=Mean[coords[[All,2]]];*)
(*(*Scale down coordinates to control graph size*)coords=coords*0.5;*)
(*(*Adjust root node (n) position to be closer to other nodes*)coords[[n]]={maxX+.7,midY};*)
(*(*Redraw the graph with adjusted coordinates*)Graph[Range[n],edges,VertexLabels->"Name",VertexCoordinates->coords,ImageSize->100]]*)
